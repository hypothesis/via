import re
from base64 import b64encode
from dataclasses import dataclass
from logging import getLogger

from via.services.http import HTTPService

LOG = getLogger(__name__)

#: Mapping of language codes to human-readable names (matching YouTube's format)
LANGUAGE_NAMES = {
    "en": "English",
    "en-us": "English (United States)",
    "en-gb": "English (United Kingdom)",
    "en-au": "English (Australia)",
    "en-ca": "English (Canada)",
    "en-in": "English (India)",
    "es": "Spanish",
    "es-es": "Spanish (Spain)",
    "es-mx": "Spanish (Mexico)",
    "es-419": "Spanish (Latin America)",
    "fr": "French",
    "fr-fr": "French (France)",
    "fr-ca": "French (Canada)",
    "de": "German",
    "de-de": "German (Germany)",
    "it": "Italian",
    "pt": "Portuguese",
    "pt-br": "Portuguese (Brazil)",
    "pt-pt": "Portuguese (Portugal)",
    "ru": "Russian",
    "ja": "Japanese",
    "ko": "Korean",
    "zh": "Chinese",
    "zh-cn": "Chinese (Simplified)",
    "zh-tw": "Chinese (Traditional)",
    "zh-hans": "Chinese (Simplified)",
    "zh-hant": "Chinese (Traditional)",
    "ar": "Arabic",
    "hi": "Hindi",
    "nl": "Dutch",
    "pl": "Polish",
    "sv": "Swedish",
    "tr": "Turkish",
    "vi": "Vietnamese",
    "th": "Thai",
    "id": "Indonesian",
    "cs": "Czech",
    "el": "Greek",
    "he": "Hebrew",
    "hu": "Hungarian",
    "no": "Norwegian",
    "da": "Danish",
    "fi": "Finnish",
    "ro": "Romanian",
    "uk": "Ukrainian",
    "bg": "Bulgarian",
    "hr": "Croatian",
    "sk": "Slovak",
    "sl": "Slovenian",
    "sr": "Serbian",
    "ms": "Malay",
    "fil": "Filipino",
    "ta": "Tamil",
    "te": "Telugu",
    "bn": "Bengali",
    "mr": "Marathi",
    "gu": "Gujarati",
    "kn": "Kannada",
    "ml": "Malayalam",
    "pa": "Punjabi",
    "ur": "Urdu",
    "fa": "Persian",
    "sw": "Swahili",
    "af": "Afrikaans",
    "ca": "Catalan",
    "et": "Estonian",
    "lv": "Latvian",
    "lt": "Lithuanian",
}


def _get_language_name(language_code: str) -> str:
    """Get the human-readable name for a language code."""
    code_lower = language_code.lower()
    if code_lower in LANGUAGE_NAMES:
        return LANGUAGE_NAMES[code_lower]
    # Try base language (e.g., "en" from "en-US")
    base_code = code_lower.split("-")[0]
    if base_code in LANGUAGE_NAMES:
        # Format as "Language (Code)" for unknown variants
        base_name = LANGUAGE_NAMES[base_code]
        if "-" in language_code:
            return f"{base_name} ({language_code.upper().split('-')[1]})"
        return base_name
    # Fallback: capitalize the code
    return language_code.upper()


@dataclass
class TranscriptInfo:
    """Information about a YouTube video transcript."""

    language_code: str
    """The transcript's language code, e.g. "en-us"."""

    name: str
    """The transcript's name, e.g. "English (United States)"."""

    url: str
    """The transcript's download URL."""

    autogenerated: bool
    """Whether or not the transcript was autogenerated by speech recognition."""

    video_id: str
    """The YouTube video ID."""

    @property
    def id(self) -> str:
        """Return a unique ID for this transcript."""
        return ".".join(
            [
                self.language_code,
                "a" if self.autogenerated else "",
                b64encode(self.name.encode("utf-8")).decode("utf-8"),
            ]
        ).rstrip(".")


class YouTubeTranscriptService:
    """A service for getting text transcripts of YouTube videos using Supadata API."""

    SUPADATA_API_URL = "https://api.supadata.ai/v1/transcript"

    def __init__(self, http_service: HTTPService, api_key: str):
        self._http_service = http_service
        self._api_key = api_key

    def get_transcript_infos(self, video_id: str) -> list[TranscriptInfo]:
        """Return the list of available transcripts for `video_id`."""
        try:
            response = self._http_service.get(
                self.SUPADATA_API_URL,
                params={"url": f"https://youtu.be/{video_id}"},
                headers={"x-api-key": self._api_key},
            )
            response.raise_for_status()
            data = response.json()

            available_langs = data.get("availableLangs", [])
            primary_lang = data.get("lang", "en")

            # Create TranscriptInfo objects for each available language
            # Use lowercase language_code to match YouTube's format
            return [
                TranscriptInfo(
                    language_code=lang.lower(),
                    # Supadata doesn't tell us if it's autogenerated, assume False
                    autogenerated=False,
                    name=_get_language_name(lang),
                    # URL format for Supadata (stores video_id and original lang code)
                    url=f"supadata://{video_id}/{lang}",
                    video_id=video_id,
                )
                for lang in available_langs
            ] or [
                # If no available languages, use the primary language from response
                TranscriptInfo(
                    language_code=primary_lang.lower(),
                    autogenerated=False,
                    name=_get_language_name(primary_lang),
                    url=f"supadata://{video_id}/{primary_lang}",
                    video_id=video_id,
                )
            ]
        except Exception:
            LOG.exception(
                "YouTubeTranscriptService.get_transcript_infos failed for video_id=%s",
                video_id,
            )
            raise

    def pick_default_transcript(
        self, transcript_infos: list[TranscriptInfo]
    ) -> TranscriptInfo:
        """Return a choice of default transcript from `transcript_infos`."""
        # Preferences matching the original YouTube implementation behavior.
        # Uses regex matching on both language_code and name.
        preferences = (
            {
                "language_code": re.compile("en"),
                "name": re.compile("English"),
                "autogenerated": False,
            },
            {
                "language_code": re.compile("en-.*"),
                "name": re.compile(r"English \(.*\)"),
                "autogenerated": False,
            },
            {
                "language_code": re.compile("en"),
                "name": re.compile(".*"),
                "autogenerated": False,
            },
            {
                "language_code": re.compile("en-.*"),
                "name": re.compile(".*"),
                "autogenerated": False,
            },
            {
                "language_code": re.compile("en"),
                "name": re.compile(".*"),
                "autogenerated": True,
            },
            {
                "language_code": re.compile("en-"),
                "name": re.compile(".*"),
                "autogenerated": True,
            },
        )

        def matches(transcript_info: TranscriptInfo, preference: dict) -> bool:
            for key in ("language_code", "name"):
                if not preference[key].fullmatch(getattr(transcript_info, key)):
                    return False
            return preference["autogenerated"] == transcript_info.autogenerated

        for preference in preferences:
            for transcript_info in transcript_infos:
                if matches(transcript_info, preference):
                    return transcript_info

        return transcript_infos[0]

    def get_transcript(self, transcript_info: TranscriptInfo) -> list[dict]:
        """Download and return the actual transcript text for `transcript_info`."""
        # Extract original lang from the URL (supadata://VIDEO_ID/LANG)
        parts = transcript_info.url.split("/")
        # Use original lang code from URL (preserves case for API call)
        original_lang = parts[3] if len(parts) > 3 else transcript_info.language_code

        try:
            response = self._http_service.get(
                self.SUPADATA_API_URL,
                params={
                    "url": f"https://youtu.be/{transcript_info.video_id}",
                    "lang": original_lang,
                },
                headers={"x-api-key": self._api_key},
            )
            response.raise_for_status()
            data = response.json()

            # Convert Supadata format (milliseconds) to our format (seconds)
            # Old format: {"text": "...", "start": float, "duration": float}
            return [
                {
                    "text": segment["text"],
                    "start": segment["offset"] / 1000.0,
                    "duration": segment["duration"] / 1000.0,
                }
                for segment in data.get("content", [])
            ]
        except Exception:
            LOG.exception(
                "YouTubeTranscriptService.get_transcript failed for video_id=%s lang=%s",
                transcript_info.video_id,
                original_lang,
            )
            raise


def factory(_context, request):
    return YouTubeTranscriptService(
        http_service=HTTPService(),
        api_key=request.registry.settings.get("supadata_api_key", ""),
    )
