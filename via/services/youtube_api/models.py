import base64
from copy import deepcopy
from dataclasses import dataclass, field
from datetime import timedelta
from itertools import zip_longest
from operator import attrgetter
from typing import Dict, List, Optional
from urllib.parse import quote_plus

import isodate

from via.services.youtube_api._nested_data import safe_get


@dataclass
class Thumbnail:
    url: str
    width: int
    height: int

    @classmethod
    def from_video_id(cls, video_id) -> dict:
        # V3 Thumbnails are highly predictable, we don't actually need the info
        # from Google. The values in the V1 stuff are all redirects to these
        # new values so the widths and heights are wrong

        if not video_id:
            return {}

        return {
            key: Thumbnail(
                url=f"https://i.ytimg.com/vi/{video_id}/{file_name}",
                width=width,
                height=height,
            )
            for key, file_name, width, height in (
                ("default", "default.jpg", 120, 90),
                ("medium", "mqdefault.jpg", 320, 180),
                ("high", "hqdefault.jpg", 480, 360),
                ("standard", "sddefault.jpg", 640, 480),
                ("maxres", "maxresdefault.jpg", 1280, 720),
            )
        }


@dataclass
class Channel:
    id: str  # pylint: disable=invalid-name
    name: str


@dataclass
class VideoDetails:
    """Metadata for the video."""

    id: str = None  # pylint: disable=invalid-name
    title: str = None
    channel: Channel = None
    duration: str = None
    thumbnails: Dict[str, Thumbnail] = None
    url: str = None

    @classmethod
    def from_v1_json(cls, data):
        """Create an instance from the `videoDetails` section of JSON."""

        duration = None
        if seconds := data.get("lengthSeconds"):
            # Convert duration to an ISO 8601 duration to match V3
            duration = isodate.duration_isoformat(timedelta(seconds=int(seconds)))

        return VideoDetails(
            id=data.get("videoId"),
            title=data.get("title"),
            channel=Channel(id=data.get("channelId"), name=data.get("author")),
            duration=duration,
            thumbnails=Thumbnail.from_video_id(data.get("videoId")),
        )

    def __post_init__(self):
        if self.id:
            self.url = self.canonical_video_url(self.id)

    @classmethod
    def canonical_video_url(cls, video_id: str) -> str:
        """
        Return the canonical URL for a YouTube video.

        This is used as the URL which YouTube transcript annotations are
        associated with.
        """
        escaped_id = quote_plus(video_id)
        return f"https://www.youtube.com/watch?v={escaped_id}"


@dataclass
class CaptionTrack:
    """A source of transcription data, in a particular language."""

    # Items which form the unique part
    language_code: str
    """Original language of the track."""

    name: Optional[str] = None
    """Human set name for the track."""

    kind: str = None
    """Is this track automatically generated by audio to text AI?"""

    translated_language_code: Optional[str] = None
    """Language to machine translate this into. Set this manually."""

    # Other items which we cannot determine from the id
    label: Optional[str] = None
    """Human readable name (determined by language + name)."""

    base_url: Optional[str] = None
    """URL to download the original language text (as XML)."""

    @classmethod
    def from_v1_json(cls, data: dict):
        """Create an instance from a `captionTrack` section of JSON."""

        label = data["name"]["simpleText"]

        return CaptionTrack(
            name=label.split(" - ", 1)[-1] if " - " in label else None,
            language_code=data["languageCode"].lower(),
            label=label,
            kind=data.get("kind", None),
            base_url=data["baseUrl"],
        )

    @classmethod
    def from_id(cls, id_string: str):
        """Create a partially filled out track from and id string."""

        data = dict(
            zip_longest(
                [
                    "language_code",
                    "auto_generated",
                    "name",
                    "translated_language_code",
                ],
                [part or None for part in id_string.split(".")],
            )
        )

        if name := data.get("name"):
            data["name"] = base64.b64decode(name.encode("utf-8")).decode("utf-8")

        if data.pop("auto_generated", None):
            data["kind"] = "asr"

        return cls(**data)

    @property
    def id(self) -> str:  # pylint: disable=invalid-name
        if self.name:
            # Ensure our ids don't contain wild characters
            name = base64.b64encode(self.name.encode("utf-8")).decode("utf-8")
        else:
            name = None

        return ".".join(
            part or ""
            for part in [
                self.language_code,
                "a" if self.is_auto_generated else None,
                name,
                self.translated_language_code,
            ]
        ).rstrip(".")

    @property
    def is_auto_generated(self) -> bool:
        """Get whether this caption track auto generated."""

        return self.kind == "asr"

    @is_auto_generated.setter
    def is_auto_generated(self, value: bool):
        self.kind = "asr" if value else None

    @property
    def url(self) -> Optional[str]:
        """Get the URL to download a transcript of this caption track."""
        if not self.base_url:
            return None

        url = self.base_url

        if self.translated_language_code:
            url += f"&tlang={self.translated_language_code}"

        return url


@dataclass
class Captions:
    """All information about captions."""

    tracks: List[CaptionTrack] = field(default_factory=list)
    """Available tracks to pick from."""

    @classmethod
    def from_v1_json(cls, data: dict):
        """Create an instance from JSON.

        This is populated from the `captions.playerCaptionsTracklistRenderer`
        section.
        """

        return Captions(
            tracks=[
                CaptionTrack.from_v1_json(track)
                for track in data.get("captionTracks", [])
            ]
        )

    def find_matching_track(
        self, preferences: List[CaptionTrack]
    ) -> Optional[CaptionTrack]:
        """
        Get a caption track which matching the preferences in order.

        This method takes the provided list of caption track objects and
        searches the available tracks for those with matching details:

        * language_code
        * name
        * is_auto_generated / kind
        * translation_language_code

        For a match to happen, we must match the first three items, and be
        translatable to the last if present.

        Earlier items are higher priority.

        :param preferences: List of partially filled out caption track objects
            which represent the caption track we would like.
        """

        def get_key(track: CaptionTrack):
            return track.language_code, track.kind, track.name

        search_keys = [get_key(preference) for preference in preferences]
        best_index, best_caption_track = None, None

        # Sort the tracks to keep the algorithm more stable! This only insulates
        # us from sorting changes, not metadata changes.
        for caption_track in sorted(self.tracks, key=attrgetter("id")):
            try:
                index = search_keys.index(get_key(caption_track))
            except ValueError:
                continue

            # Items with lower indexes are first choices for the user
            if best_index is None or best_index > index:
                best_index, best_caption_track = index, deepcopy(caption_track)

        if best_index is None:
            return None

        if target_language := preferences[best_index].translated_language_code:
            # Convert the track to a translated language if required, we've
            # checked above this is ok.
            best_caption_track.translated_language_code = target_language

        return best_caption_track


@dataclass
class PlayabilityStatus:
    is_embeddable: bool = None
    is_age_restricted: bool = None

    @classmethod
    def from_v1_json(cls, data):
        return cls(
            is_embeddable=bool(
                safe_get(data, ["microformat", "playerMicroformatRenderer", "embed"])
                or safe_get(data, ["playabilityStatus", "playableInEmbed"])
            ),
            is_age_restricted=bool(
                safe_get(data, ["playabilityStatus", "status"]) == "LOGIN_REQUIRED"
                and "age" in safe_get(data, ["playabilityStatus", "reason"])
            ),
        )


@dataclass
class Video:
    """Data for a video in YouTube."""

    caption: Optional[Captions] = None
    """Caption related information (tracks and languages)."""

    details: Optional[VideoDetails] = None
    """Metadata for the video."""

    status: PlayabilityStatus = None
    """Indicator of whether the video can be played."""

    @classmethod
    def from_v1_json(cls, data):
        return Video(
            caption=Captions.from_v1_json(
                safe_get(data, ["captions", "playerCaptionsTracklistRenderer"], {})
            ),
            details=VideoDetails.from_v1_json(data.get("videoDetails", {})),
            status=PlayabilityStatus.from_v1_json(data),
        )


@dataclass
class TranscriptText:
    """An individual row of transcript text."""

    text: str
    start: float
    duration: float


@dataclass
class Transcript:
    """A full transcript from a caption track."""

    track: CaptionTrack
    text: List[TranscriptText]
